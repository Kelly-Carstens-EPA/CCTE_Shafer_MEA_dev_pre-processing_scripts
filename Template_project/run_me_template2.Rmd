---
title: "MEA NFA script to complete pre-processing steps"
author: ""
date: ""
output: 
  html_document:
    toc: true
    toc_float: true
    number_sections: true
    code_folding: show
    df_print: kable
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE)
```

# Set up

## Load libraries 

```{r}
# General packages
library(data.table)
library(openxlsx)
library(ggplot2)
library(stringi)
# library(RMySQL) # only needed if querying invitrodb directly

# Packages for parameter calculation scripts/functions
library(rhdf5) # used to create and read h5files, which is currently used as input to calculate all parameter values
library(sjemea, exclude = c('construct.s','map2list')) # original package with functions to calculate parameters. Excluding objects that will be loaded with the meadq package
library(meadq) # package with wrapper and/or modifications to several functions in sjemea
library(pracma, exclude = 'peaks') # used for MI and trapz function for AUC calculation. Excluding the 'peaks' function because we want the 'peaks function from sjemea
library(compiler) # used for MI calculation
library(gtools, exclude = 'logit') # used for MI  calculation. Excluding logit becasue conflicts with pracma package

print(sessionInfo())
```


## Project variables definitions 

```{r}
project_name <- "Test2023" # e.g. "name2020"

spidmap_file <- "" # path to file that maps treatment names to sample IDs (optional)
spid_sheet <- "" # desired sheet in spidmap_file (can be numeric or the sheet name) (optional)

project.input.dir <- "L:/Lab/NHEERL_MEA/Project - DNT Test Set 2021 NTP" # main folder of experimental data for project
scripts.dir <- "C:/Users/acarpe01/Documents/local_repos/CCTE_Shafer_MEA_dev_pre-processing_scripts_test/R" # directory containing the pre-processing scripts for the NFA
root.output.dir <- "C:/Users/acarpe01/Documents/local_repos/data_process_prac" # main directory where the output should be saved
assay_component_map_filename <- "C:/Users/acarpe01/Documents/local_repos/CCTE_Shafer_MEA_dev_pre-processing_scripts_test/mea_nfa_component_name_map.csv"

project.output.dir <- file.path(root.output.dir, project_name)
if (!dir.exists(project.output.dir)) dir.create(project.output.dir)
```

If the scripts.dir is managed with version control, check that there are no local or uncommitted modifications, and then enter the following information to record the branch and most recent commit to the pre-processing scripts repository: 

* **branch**: <enter branch>
* **commit date**: <enter commit date>
* **commit message**: <enter commit message>
* **commit SHA**: <enter commit SHA>
* **link to scripts**: <GitHub link followed by commit SHA>

```{r}
# Source scripts containing functions that may be used throughout

# Functions to read and write files log
source(file.path(scripts.dir, 'writeFilesLog.R'))
source(file.path(scripts.dir, 'readFilesLog.R'))

objects.to.keep <- c(ls(),'objects.to.keep')
```


# Check for READMEs and other well quality notes in project folder 

Scan for txt files with notes that might affect dosing, wllq
```{r}
txt.files <- list.files(project.input.dir, pattern = '\\.txt', recursive = T, full.names = T)
```

View any README .txt files
```{r}
# Read in the READMEs
readmes.filename <- txt.files[grepl('read( )*me',tolower(txt.files))]
readmes.body <- sapply(readmes.filename, scan, what = character(), sep = '\n', quiet = T) # read the text files
readmes.body <- sapply(readmes.body, paste0, collapse = "\n") # Make each note 1 string

# If the README file only contains this generic text, then don't need to view
# (modify as needed)
generic.readme.text <- 'The following wells have been discarded from the Alamar Blue assay due to returning results outside the acceptable bounds of the assay:
X

The following wells have been discarded from the LDH assay due to returning results outside the acceptable bounds of the assay:
X'
readmes.body <- readmes.body[readmes.body != generic.readme.text]

# View the readmes that have any non-generic text
if (length(readmes.body) > 0) {
  for (i in 1:length(readmes.body)) {
    cat(i,'\n')
    cat(names(readmes.body)[i],'\n')
    cat(readmes.body[i])
    cat('\n\n')
  }
}
```


Check for any other .txt files that appear may have relevant notes

```{r}
cat(setdiff(txt.files,readmes.filename), sep = "\n")
```


# Identify source experimental and meta data files

Get the list of group folders from which you want to extract data
```{r}
group.folders <- list.files(path = project.input.dir, 
                            pattern = ".*[0-9]{8}.*", 
                            full.names = T, 
                            recursive = F)
group.folders
```

For each group folder, get the desired files (files containing cytotoxicity data, meta data, and spike list files) and save in the vector 'all.files'

```{r}
# Function to extract desired files for a given culture that is organization in the standard structure
# Modify as needed for the given project
get_NFA_files_by_group <- function(group.folderi) {
  cytotox.files <- list.files(path = group.folderi, 
                              pattern = '(Calculations)|(Summary)', 
                              full.names = T)
  mfiles <- list.files(path = group.folderi,
                       pattern = 'MaestroExperimentLog',
                       full.names = T, recursive = T)
  slists <- list.files(path = group.folderi, 
                       pattern = '_spike_list\\.csv', 
                       full.names = T, recursive = T)
  filesi <- c(cytotox.files, mfiles, slists)
  return(filesi)
}

# For each culture, apply the above function to get the list of files
all.files <- c()
for (group.folderi in group.folders) {
  all.files <- c(all.files, get_NFA_files_by_group(group.folderi))
}

# Basic cleaning:
# Remove files dummy "ghost" files that contain "~$" in the file name
all.files <- Filter(function(filei) !grepl('\\Q~$\\E',filei), all.files)
# Remove files that contain the word "deprecated" anywhere in the file name
all.files <- Filter(function(filei) !grepl('deprecated',tolower(filei)), all.files)

# Additional filters as needed:

# Total number of files
length(all.files)
```

Check for the expected number of files per group

```{r}
for (group.folder in group.folders) {
  cat("\n\n",group.folder,"\n",sep = "")
  group.folder <- sub("\\(","\\\\(",group.folder)
  group.folder <- sub("\\)","\\\\)",group.folder)
  group.folder.files <- grep(group.folder, all.files, fixed = T, val = T)
  
  cat("Calculations/Summary files: ")
  cat(sum(grepl("(Calculations)|(Summary)",group.folder.files)))
  cat(' (',paste0(basename(grep("(Calculations)|(Summary)",group.folder.files, val = T)),collapse = ", "),')\n')
  
  cat("Number of MaestroExperimentLog files: ")
  cat(sum(grepl("MaestroExperimentLog",group.folder.files)),"\n")
  
  cat("Number of spike list files: ")
  cat(sum(grepl("_spike_list",group.folder.files)),"\n")
  
}
```

Save a log of the selected source files for reference

```{r eval = FALSE}
writeFilesLog(all.files, files.log.dir = project.output.dir, project_name = project_name)
rm(list = setdiff(ls(), objects.to.keep))
```



# Extract raw data, calculate features, and calculate area under the curve

Functions to source:

```{r}
source(file.path(scripts.dir, 'spike_list_functions.R'))
source(file.path(scripts.dir, 'h5_conversion.R'))

source(file.path(scripts.dir,'create_ont_csv.R'))
source(file.path(scripts.dir,'create_burst_ont_Data.R'))
source(file.path(scripts.dir,'local.corr.all.ont.ae.filter.R'))

source(file.path(scripts.dir,'spikeLoadRoutines.R'))
source(file.path(scripts.dir,'nmi2_final.R'))
source(file.path(scripts.dir,'nmi_wrapper.R'))
source(file.path(scripts.dir,'MI_script_all.R'))

# AUC
source(file.path(scripts.dir,'prepare_parameter_values.R'))
source(file.path(scripts.dir,'linear_interpolate_DIV.R'))
source(file.path(scripts.dir,'add_wllq_by_well.R'))
source(file.path(scripts.dir,'parameter_values_to_AUC.R'))

# Extracting the cytotoxicity data
source(file.path(scripts.dir,'run_cytotox_functions.R'))
source(file.path(scripts.dir,'createCytoTable2.R'))
source(file.path(scripts.dir,'createCytoData.R'))
```

**Convert spike list files to h5 files**
```{r}
h5_conversion(project.output.dir, 
              files.log.output.dir = project.output.dir,
              remake_all = FALSE, 
              check_nwells_per_plate = 48, 
              recording_duration_sec = 900.00)
```

**Calculate micro-electrode array parameter values**

```{r}
create_ont_csv(project.output.dir, 
               remake_all = FALSE,
               get_h5Files_under_project.output.dir = TRUE)
```

**Calculate normalized mutual information**

```{r}
run_mi_functions(project.output.dir, 
                 get_h5Files_under_project.output.dir = TRUE, 
                 remake_all = FALSE)
```

**Calculate Area-Under-the-Curve values**

Combine all parameter data files, update well quality by well, add dummy points at DIV 2, and check for non-standard DIV.
```{r}
# Get paths to the parameter data files & wllq table
div_data_file_folders <- file.path(project.output.dir,c('prepared_data','All_MI'))
div_data_files <- unlist(lapply(div_data_file_folders, list.files, pattern = '.csv$', full.names = TRUE, recursive = FALSE))
wllq.tb.by.well.file <- file.path(project.output.dir, 
                                  paste0(project_name,'_well_quality_assignments_by_well.csv'))

# Run the function
prepare_parameter_values(project.output.dir, 
                         project_name, 
                         div_data_files = div_data_files,
                         id.columns = c("date","Plate.SN","DIV","well","trt","dose","units","file.name"),
                         wllq.tb.by.well.file = wllq.tb.by.well.file,
                         num_rows_per_plate = 6,
                         num_columns_per_plate = 8,
                         expected_DIVs = c(5,7,9,12),
                         add_DIV2_values_of_0 = TRUE,
                         interpolate_stnd_DIVs = TRUE)
```

Calculate the trapzoidal area under the curve for each well/parameter versus the DIV

```{r}
# Get single DIV data file created above
div_data_file <- file.path(project.output.dir,'output',paste0(project_name,'_parameters_by_DIV.csv'))

# Run the function
parameter_values_to_AUC(project.output.dir, 
                        project_name, 
                        div_data_file = div_data_file,
                        id.columns = c("date","Plate.SN","DIV","well","trt","dose","units","file.name","wllq_by_well","wllq_notes_by_well","wllq_ref_by_well"),
                        expected_DIVs = c(2,5,7,9,12),
                        dose_column_name = 'dose')
```

**Extract the cytoxicity data**

```{r}
wllq.tb.by.well.file <- file.path(project.output.dir, 
                                  paste0(project_name,'_well_quality_assignments_by_well.csv'))
run_cytotox_functions(project.output.dir, project_name, 
                      get_files_from_log = TRUE, 
                      wllq.tb.by.well.file = wllq.tb.by.well.file)
```


# Prepare the level 0 table

Remove extra objects from environment

```{r}
rm(list = setdiff(ls(),objects.to.keep))
```

Read in the files under the "output" folder (_parameters_by_DIV, _AUC, _cytotox), convert to long-format (1 row per parameter), and combine into 1 table.

```{r}
source(file.path(scripts.dir, 'tcpl_MEA_dev_AUC.R'))
dat <- tcpl_MEA_dev_AUC(project.output.dir, 
                        project_name, 
                        assay_component_map_filename,
                        id.columns = c("date","Plate.SN","DIV","well","trt","dose",
                                       "units","file.name","wllq_by_well","wllq_notes_by_well","wllq_ref_by_well"))
```


# Confirm treatments are consistent (and correct)

```{r}
# before dive in too much further, let's confirm consistent treatment labels by wells
dat[, .(length(unique(treatment))), by = .(apid, rowi, coli)][V1 > 1]
# empty, cool!
```




## Updated treatment label for solvent control wells 
```{r}
dat[, treatment_srcf := treatment]
dat[wllt == 'n', .N, by = .(treatment)][order(-N)] # wllt == 'n' determined where conc_original == 0
# Note: "Water" is currently used in other MEA NFA data in ToxCast
# So will change H2O to "Water" for consistency
dat[treatment == 'H2O', treatment := 'Water']

dat[wllt == 'n', .N, by = .(treatment, conc)][N > 6][order(-N)]
#        treatment conc     N
# 1:          DMSO    0 26265
# 2:           Water    0  1275
# 3:       7126 A3    0    12
# 4:   Bisphenol A    0    12
# 5: Acetamenophin    0    12
# Wait, why only 12 points for some of these? Shouldn't there be 1 for every plate adn acsn?
dat[wllt == 'n' & treatment %in% c('7126 A3','Bisphenol A','Acetamenophin'), .N, by = .(treatment, acsn)]
# treatment                    acsn N
# 1:       7126 A3  CCTE_Shafer_MEA_dev_AB 6
# 2:   Bisphenol A  CCTE_Shafer_MEA_dev_AB 6
# 3: Acetamenophin  CCTE_Shafer_MEA_dev_AB 6
# 4:       7126 A3 CCTE_Shafer_MEA_dev_LDH 6
# 5:   Bisphenol A CCTE_Shafer_MEA_dev_LDH 6
# 6: Acetamenophin CCTE_Shafer_MEA_dev_LDH 6
dat[wllt == 'n' & !grepl('(LDH)|(AB)',acsn), .N, by = .(treatment)]
# treatment     N
# 1:      DMSO 26265
# 2:       Water  1275
# ah okay! So in the maestro log files, Seline entered the control treatment name
# whereas in the past and now still for the cyto assays, the control wells are just indicated by a conc of 0
# but the treatment name for the given row is used

# For which chemicals is implied that Water was used, based on Water is same-row control column?
water.plate.rows <- dat[treatment == 'Water', unique(.SD), .SDcols = c('apid','rowi','srcf')]
setkey(dat, apid, rowi, srcf)
dat[.(water.plate.rows)][wllt != 'n', .N, by = .(treatment)]
# treatment    N
# 1:   7126 H8 1785
# 2:   7126 H9 1785
# 3:  7126 H10 1785
# 4:  7126 H11 1785
# 5:  7126 G10 1785
treatments.same.row.water <- dat[.(water.plate.rows)][wllt != 'n', unique(treatment)]
check.treatment.rows <- dat[treatment %in% treatments.same.row.water, unique(.SD), .SDcols = c('apid','rowi','srcf')]
dat[J(check.treatment.rows)][wllt == 'n', .N, by = .(treatment)] # confirm all of these are Water, or same chem name as for LDH/AB
# treatment    N
# 1:   7126 H8    6
# 2:       Water 1275
# 3:   7126 H9    6
# 4:  7126 H10    6
# 5:  7126 H11    6
# 6:  7126 G10    6
# yep, looks okay!

# Standarize control treatment names for LDH/AB
dat[wllt == 'n', treatment := ifelse(treatment %in% c('Water',treatments.same.row.water), 'Water', 'DMSO')]

# Note the solvent control sued for each substance
dat[wllt == 't', solvent := ifelse(treatment %in% treatments.same.row.water, 'Water', 'DMSO')]

# Set the control well concentration. Adjust as needed
# dat[wllt == "n", conc := 0.001]
dat[wllt == "n", conc := 0.1]  # previously I entered this as 0.001, as a fraction, but now I"m going to enter it as 0.1 with units "%"
dat[wllt == "n", units := '%']  # previously I entered this as 0.001, as a fraction, but now I"m going to enter it as 0.1 with units "%"

```

# Prepare columns needed for TCPL lvl0 table

## acsn, anm

## apid

Placeholder to update this in the future if we want to do something more sophisticated than what is currently done in `tcpl_MEA_dev_AUC()`

## srcf

Placeholder to update this in the future if we want to do something more sophisticated than what is currently done in `tcpl_MEA_dev_AUC()`

## spids 

```{r}
# We don't have sample id's actually, instead I'm goign to assign the blind code
spidmap <- as.data.table(read.xlsx(spidmap_file, sheet = spid_sheet))
head(spidmap)
# 2nd col name is "Conc..(mM)"
# unique(spidmap$Concentration_Unit) # all mM?
unique(dat$units) # confirm these are all uM (this taken from maestroexperiment log file)

# Kathleen said that she used the last 4 digits of the plate No plus the plate position as the treatment names
basename(spidmap_file) # "Coded Plate Map - Plate No. 4001207126 DNT HEI EPA SHIP CHEM14214 MRI3110.xlsx"
spidmap[, treatment := paste0('7126 ',Plate.Position)]
# don't have spids get, just the blind codes
# setnames(spidmap, old = c(trt_col, spid_col), new = c("treatment","spid"))
# for example, setnames(spidmap, old = c("Aliquot_Vial_Barcode", "Concentration", "EPA_Sample_ID"), new = c("treatment","stock_conc","spid"))
spidmap[, sheet_stock_conc_units := 'mM']
spidmap[is.na(as.numeric(`Conc..(mM)`))]
spidmap[, conc_numeric_test := as.numeric(`Conc..(mM)`)]
spidmap[is.na(conc_numeric_test)]

# Remove rows that just contain notes, not chemical info
notes.tb <- spidmap[is.na(Plate.Position)]
spidmap <- spidmap[!is.na(Plate.Position)]

# extract the footnotes in another column
# then remove from main columns
spidmap[, footnote_chars := paste0(gsub('[0-9a-zA-Z \\.]*','',`Blind-Code`), ',', gsub('[0-9a-zA-Z \\.]*','',`Conc..(mM)`), ',', gsub('[0-9a-zA-Z \\.]*','',Plate.Position))]
spidmap[, c('Blind-Code','Conc..(mM)','Plate.Position') := lapply(.SD, function(coli) stri_extract(coli, regex = '[0-9a-zA-Z \\.]+')), .SDcols = c('Blind-Code','Conc..(mM)','Plate.Position')]
spidmap[, conc_numeric_test := as.numeric(`Conc..(mM)`)]
spidmap[is.na(conc_numeric_test)]
# empty, cool!

spidmap[, treatment := as.character(treatment)]
setnames(spidmap, old = 'Blind-Code', new = 'DNTP_blind_code')
setnames(spidmap, old = 'Conc..(mM)', new = 'sheet_stock_conc')


# Add additional spidmap's if needed and rbind into 1 spidmap
setdiff(dat$treatment, spidmap$treatment)
spidmap2 <- as.data.table(read.xlsx('L:/Lab/NHEERL_Mundy/Project - DNT Test Set 2021 NTP/Coded Plate Map - Plate No. 7000439163 DNT HEI EPA SHIP CHEM14214 MRI3110.xlsx', sheet = spid_sheet))
spidmap2[, treatment := paste0('9163 ',Plate.Position)]
spidmap2[, conc_numeric_test := as.numeric(`Conc..(mg/mL)1`)]
spidmap2[, sheet_stock_conc_units := 'mg/mL']
spidmap2[is.na(conc_numeric_test)] # several...
notes.tb <- rbind(notes.tb, spidmap2[is.na(Plate.Position)], fill = T) # remove rows that just contain notes
spidmap2 <- spidmap2[!is.na(Plate.Position)] # remove rows that just contain notes
spidmap2[, footnote_chars := paste0(gsub('[0-9a-zA-Z \\.]*','',`Blind-Code`), ',', gsub('[0-9a-zA-Z \\.]*','',`Conc..(mg/mL)1`), ',', gsub('[0-9a-zA-Z \\.]*','',Plate.Position))]
spidmap2[, c('Blind-Code','Conc..(mg/mL)1','Plate.Position') := lapply(.SD, function(coli) stri_extract(coli, regex = '[0-9a-zA-Z \\.]+')), .SDcols = c('Blind-Code','Conc..(mg/mL)1','Plate.Position')]
spidmap2[, conc_numeric_test := round(as.numeric(`Conc..(mg/mL)1`), digits = 0)]
spidmap2[is.na(conc_numeric_test)] # empty now, cool
spidmap2[, treatment := as.character(treatment)]
setnames(spidmap2, old = 'Blind-Code', new = 'DNTP_blind_code')
setnames(spidmap2, old = 'Conc..(mg/mL)1', new = 'sheet_stock_conc')

# Combine spidmaps
spidmap <- rbind(spidmap, spidmap2)
# Manually add assay controls to spidmap
spidmap <- rbind(spidmap, data.table('treatment' = c('Bisphenol A','Acetaminophen'),
                                     'DNTP_blind_code' = c('Bisphenol A','Acetaminophen')), fill = T)
setdiff(dat$treatment, spidmap$treatment)
# [1] "DMSO"          "Water"         "Acetamenophin" "7258 G01"      "7258 G1"       "7258 G02"      "7258 G2"       "7258 H01"      "7258 H1"
# Correct spelling of assay control in data
dat[treatment %in% c('Acetamenophin'), treatment := 'Acetaminophen']
setdiff(dat$treatment, spidmap$treatment)
# [1] "DMSO"     "Water"    "7258 G01" "7258 G1"  "7258 G02" "7258 G2"  "7258 H01" "7258 H1"
# huh, I though there were just 3 compounds from the PFAS Plus up set tested on these plates...
dat[!treatment %in% c(spidmap$treatment, c('DMSO','Water')), .N, by = .(treatment, apid)]
check.apids <- dat[!treatment %in% c(spidmap$treatment, c('DMSO','Water')), unique(apid)]
dat[apid %in% check.apids & wllt == 't', .N, by = .(treatment, apid)][order(apid, treatment)]
# wait, why some plates have 9 unique treatments?
# Oh, gotcha, this is probably a difference in how the treatments are represented (e.g. G01 vs G1)
# So I can safely assume that all treatments that begin with 7258 are some modification of the PFAS Plus up spid, adn cna be removed from this data set

# Is NTP going to want to use the 1st and 2nd lowest conc to normalize the data?
# Or are they going to use our methods, which only uses the control wells?
# I believe that they are going to try to mimic our methods. But I can add a note in case not.
dat <- dat[treatment %in% c(spidmap$treatment, c('DMSO','Water'))]

# Triage notes below for incorporation/needed checks, mostly to confirm solvent used and stock conc
notes.tb[, .(`Blind-Code`)]
# Blind-Code
# 1: Note: Blank DMSO, CAS No: 67-68-5, Supplier: Gaylord Chemical Company LLC. Lot # USP180404, CoA Purity: 100.0%, Amount: 50 mL, Suggested Storage: Ambient
# 2:                  Note: Blank Water, CAS No: 7732-18-5, Supplier: Labconco Water Pro PS. 18.2 M<U+2126>·cm, Amount: 50 mL, Suggested Storage: Refrigerate
# 3:                                                                              Note: Argon gas headspace added to chemical vials prior to storage/shipment.
# 4:                           Vial Type: polypropylene, 1.4-mL alphanumeric screw-cap tubes, 96-vial plate rack, polypropylene screw-cap with silicon o-ring.
# 5:                                                                                                                a Water solution; max DMSO solubility 2 mM
# 6:                                                                                                                       ß Water solution; insoluble in DMSO
# 7:                                                                                                        <U+03B3> Water solution; max DMSO solubility 10 mM
# 8:                                                                                                                         <U+0394> Cholinesterase Inhibitor
# 9:                                                                              Note: Argon gas headspace added to chemical vials prior to storage/shipment.
# 10:                           Vial Type: polypropylene, 1.4-mL alphanumeric screw-cap tubes, 96-vial plate rack, polypropylene screw-cap with silicon o-ring.
# 11:                                                                                                         1 Complex mixture in DMSO, concentration in mg/mL
# 12:                                                                                                           ** Exact concentration could not be determined.

# translating this smoothly is getting tricky with the non-standard symbols (alpha, beta, delta, etc)
# Opening up spidmap 1 in excel, looks like:
# H8 = Water solution; max DMSO solubility 2 mM
# H9, H10 = Water solution; insoluble in DMSO
# H11 = Water solution; max DMSO solubility 10 mM
# Opening spidmap2: "1 Complex mixture in DMSO, concentration in mg/mL" applies to the entire column "Conc..(mg/mL)1"
# "Exact concentration could not be determined." applies to the 9 instances wherever "**" appears in conc column
# Conc for these substances is actually "<= 10"
spidmap[, .N, by = .(footnote_chars)]
spidmap[, footnote_chars := sub('^,', '', footnote_chars)]
spidmap[, footnote_chars := sub(',*$', '', footnote_chars)]
spidmap[, .N, by = .(footnote_chars)]

# from spidmap1:
spidmap[treatment %in% paste0("7126 H",c(8:11)), .(treatment, footnote_chars)]
# treatment footnote_chars
# 1:   7126 H8              a
# 2:   7126 H9              ß
# 3:  7126 H10              ß
# 4:  7126 H11       <U+03B3>
# cool, that lines up with findings
spidmap[treatment == '7126 H8', footnote := 'Water solution; max DMSO solubility 2 mM']
spidmap[treatment %in% c('7126 H9','7126 H10'), footnote := 'Water solution; insoluble in DMSO']
spidmap[treatment == '7126 H11', footnote := 'Water solution; max DMSO solubility 10 mM']

# From spidmap2
spidmap[grepl('\\*\\*',footnote_chars)] # yep, 9 cases, all from plate 9163
spidmap[grepl('\\*\\*',footnote_chars), footnote := 'Coded Plate Map stock conc <= 10. Exact concentration could not be determined.']

# All footnotes addressed?
spidmap[!is.na(footnote_chars) & footnote_chars != '' & is.na(footnote)]
spidmap[!is.na(footnote_chars) & footnote_chars != '' & is.na(footnote), .N, by = .(footnote_chars)]
#    footnote_chars  N
# 1:       <U+0394> 21
# ah, all of these are footnote char <U+0394>
# which corresponds to a note the that substances is a cholinesterase inhibitor. I dont' need to note that here
# but might as well for completeness
spidmap[grepl('U\\+0394',footnote_chars)] # this doesn't work... not sure how to reference!
spidmap[!is.na(footnote_chars) & footnote_chars != '' & is.na(footnote), footnote := 'Cholinesterase Inhibitor']

# How will I address these notes?
spidmap[, .N, by = .(footnote)]
# Confirm that substances with note of water solution match the solvent I assigned
# where exact conc couldn't be determined - I feel compelled to report that in the well quality, but they should know that
# will implement below after merge in spidmap

# Visually confirm the conc's look correct, that nothing weird happened with extracting the true values
View(spidmap)

# check if every treatment name from the mea data maps to a unique sample in spidmap
setdiff(dat$treatment, spidmap$treatment) # "DMSO"          "Water"  -> need to update spellign for acetaminophen
setdiff(dat$treatment, spidmap$treatment) # "DMSO"          "Water"
spidmap[treatment %in% unique(dat$treatment), .N, by = .(treatment)][N > 1] # checking for treatments that match multiple spid
# if there is not a 1-to-1 correspondence, update treatment names in "supplemental_mea_treatment_name_map.csv"

# update treatment names with entries in "supplemental_mea_treatment_name_map.csv" corresponding to dataset
# (treatment -> "mea_treatment_name", "updated_treatment_name" column will match "PREFERRED_NAME"
# dat <- update_treatment_names(dat, root.output.dir, project_name)

# assign spids
# dat <- check_and_assign_spids(dat, spidmap)
# this fun:
check_and_assign_spids <- function(dat, spidmap) {
  if (length(setdiff(c("treatment","spid"), names(spidmap))) > 0) {
    stop("The following columns are not found in spidmap: ",paste0(setdiff(c("treatment","spid"), names(spidmap)),collapse =","))
  }
  if (spidmap[!is.na(spid) & treatment %in% unique(dat$treatment), .(length(unique(spid))), by = "treatment"][,any(V1 !=1)]) {
    stop(paste0("The following treatments map to multiple spids: ",
                spidmap[!is.na(spid) & treatment %in% unique(dat$treatment), .(length(unique(spid))), by = "treatment"][V1 != 1,paste0(treatment,collapse=", ")]))
  }
  dat <- merge(dat, spidmap[, .(spid, treatment)], by = "treatment", all.x = TRUE)
  dat[wllt != 't' & is.na(spid), spid := treatment]
  if (dat[wllt == "t", any(is.na(spid))]) {
    cat("The following treatments don't have a corresponding spid in the spidmap:\n")
    print(dat[wllt == "t" & is.na(spid), unique(treatment)])
    stop("Adjust input dat before continuing")
  }
  return(dat)
}


# can't use this fun, since I'm not actually assinging spids
# adapted:
if (spidmap[!is.na(DNTP_blind_code) & treatment %in% unique(dat$treatment), .(length(unique(DNTP_blind_code))), by = "treatment"][,any(V1 !=1)]) {
  stop(paste0("The following treatments map to multiple DNTP_blind_codes: ",
              spidmap[!is.na(DNTP_blind_code) & treatment %in% unique(dat$treatment), .(length(unique(DNTP_blind_code))), by = "treatment"][V1 != 1,paste0(treatment,collapse=", ")]))
}
dat <- merge(dat, spidmap[, .(DNTP_blind_code, treatment, footnote_chars, footnote)], by = "treatment", all.x = TRUE)
dat[wllt != 't' & is.na(DNTP_blind_code), DNTP_blind_code := treatment]
if (dat[wllt == "t", any(is.na(DNTP_blind_code))]) {
  cat("The following treatments don't have a corresponding DNTP_blind_code in the spidmap:\n")
  print(dat[wllt == "t" & is.na(DNTP_blind_code), unique(treatment)])
  stop("Adjust input dat before continuing")
}

# Confirm that substances with note of water solution match the solvent I assigned
dat[grepl('Water',footnote), .N, by = .(treatment, solvent)]
# treatment solvent    N
# 1:  7126 H10   Water 3654
# 2:  7126 H11   Water 1827
# 3:   7126 H8   Water 1827
# 4:   7126 H9   Water 1827
# all water, cool
dat[solvent == 'Water', .N, by = .(treatment, solvent, footnote)]
# treatment solvent                                  footnote    N
# 1:  7126 G10   Water                                      <NA> 1827
# 2:  7126 H10   Water         Water solution; insoluble in DMSO 3654
# 3:  7126 H11   Water Water solution; max DMSO solubility 10 mM 1827
# 4:   7126 H8   Water  Water solution; max DMSO solubility 2 mM 1827
# 5:   7126 H9   Water         Water solution; insoluble in DMSO 1827
# Kathleen mentioned 7/25/22 that she was originally given G10 in DMSO, but before she tested it, she was given a new sample that was dissolved in water instead.

# Where exact conc couldn't be determined - I feel compelled to report that in the well quality, but they should know that
dat[grepl('could not be determined',footnote), .N, by = .(treatment, footnote)]
# 9 substances
dat[footnote == 'Coded Plate Map stock conc <= 10. Exact concentration could not be determined.',
    wllq_notes_by_well := paste0(ifelse(is.na(wllq_notes_by_well) | wllq_notes_by_well == '', '', paste0(wllq_notes_by_well,'; ')),
                                 footnote)]
```


## wllt (well type)
```{r}

# see other run_ms:
# Assign wllt (well type)
longdat[, wllt := "t"]
longdat[ conc == 0, wllt := "n"]

```


# Confirm concentrations and units

## basic conc checks

## Compare conc's with expected conc based on stock conc & conc index

```{r}
# get the culture, to facilate below checks
dat[, culture := sub('_.*','',apid)]

# confirm that the conc's collected from master chem lists and Calc files match
# and that the correct concentration-corrections has been done for each compound
dat[, conc_srcf := conc] # save the original conc's in a column
dat[, conc_log10 := log10(conc)]
```

## Make conc's consistent across srcfs 
```{r}
# Sometimes conc's appear differently with the data pulled from the master chemical list,
# then modified with as.character(signif(dose, 4)) in burst_parameter_to_AUC.R,
# compared to the conc's pulled from the Calculations files for the cytotoxicity data.
# But if they differ by a very small amount, then will make things easier if standardize.
# In the future, will only get conc's from Calculation files.

# In Carstens et al., 2022, the AC50s from replicates in the NFA were found to vary by approximately +/- 0.5 log10 uM.
# Therefore, I think that any variability in the concentrations due to differences in data processing of decimal places/signficant figures
# is negligible if it is less that 0.005 log10-uM (2 orders of magnitude lower).
# Even 0.05 log10-uM is probably okay.

dat[, conc_calc_file := unique(conc[grepl('Calculations',srcf)]), by = .(culture, apid, treatment, rowi, coli)]
dat[, conc_calc_file_log10 := log10(conc_calc_file)]
dat[is.na(conc_calc_file)] # empty, good
dat[abs(conc_log10 - conc_calc_file_log10) >= 0.005, .N, by = .(treatment, conc, conc_calc_file, culture, apid, srcf)][order(treatment, conc)] # not empty, hmm...

# 07/26/2022: I just looked at Master Exp log files for 20211124_MW78-6215 and 20211124_MW78-6216
# Looks like the stock-conc corrected concentrations were not rotated along with the treatments in these files
# Totally understandable, since these conc's have to be edited by hand as the treatments rotate across the 3 plates in the group
# But the treatments and conc's are automatically rotated with the formulas in excel used in the Calculations files
# Based on above output, the order of magnitude is still on par for the conc and the conc_calc_file in all of these cases.
# So I will default to the concentration from teh calc file, with a note.
# Double check these 2 plates cover all cases of concern:
dat[abs(conc_log10 - conc_calc_file_log10) >= 0.005, .N, by = .(culture, apid, wllt)]
# culture               apid wllt    N
# 1: 20211124 20211124_MW78-6215    t 1190
# 2: 20211124 20211124_MW78-6216    t 1190
dat[culture == '20211124' & apid %in% c('20211124_MW78-6215','20211124_MW78-6216') & wllt == 't',
    conc_correction_note := 'Stock-concenetration corrected values were not manually rotated correctly to match the treatments in the MastroExp Log for plates MW78-6215, MW78-6216. Defaulting to concentrations in Calculations file in corresponding plates and wells.']

# Standardize conc's to all come from the same srcf
dat[, conc := conc_calc_file]
dat[, conc_log10 := log10(conc)]

# Check after updates:
dat[abs(conc_log10 - conc_calc_file_log10) >= 0.005, .(treatment, conc, conc_calc_file)] # not empty, hmm...
# empty, cool

# Assign cndx (concentration index)
dat[wllt == 't', .(length(unique(conc))), by = .(treatment, apid)][V1 != 7]
# empty -> cool
dat[, cndx := frank(conc, ties.method = 'dense'), by = .(treatment, apid)]
dat[, summary(cndx)] # max should be 7 for 48-well plates with 1 column for controls

```

## Check if conc's have been adjusted to the stock conc corrrectly
```{r}
# Merge in stock conc's from spidmap
dat <- merge(dat, spidmap[, .(DNTP_blind_code, treatment, sheet_stock_conc, sheet_stock_conc_units)], by = c('DNTP_blind_code','treatment'), all.x = T)
dat[, sheet_stock_conc := as.numeric(sheet_stock_conc)]

# Default dilution scheme shown below
# It's okay if the the scheme is different for a few substances.
# Can update dilution_factor for individual treatments later.
dilution.tb <- data.table(cndx = 7:1)
dilution.tb[cndx == 7, dilution_cndx_multiplier := 1]
dilution.tb[cndx == 6, dilution_cndx_multiplier := 15/(35+15)]
dilution.tb[cndx == 5, dilution_cndx_multiplier := 15/(15+30)]
dilution.tb[cndx == 4, dilution_cndx_multiplier := 15/(35+15)]
dilution.tb[cndx == 3, dilution_cndx_multiplier := 15/(15+30)]
dilution.tb[cndx == 2, dilution_cndx_multiplier := 15/(35+15)]
dilution.tb[cndx == 1, dilution_cndx_multiplier := 15/(15+30)]
dilution.tb[, dilution_factor := Reduce(f = `*`, dilution_cndx_multiplier, accumulate = TRUE)]
dilution.tb

# Merge in dilution scheme
dat <- merge(dat, dilution.tb[, .(cndx, dilution_cndx_multiplier, dilution_factor)], by = 'cndx', all.x = T)

# Calculate my anticipated concentrations based on dilutions
dat[, top_conc := as.numeric(sheet_stock_conc)] # for starters, assume top_conc is same as sheet_stock_conc
dat[, my_anticipated_conc := top_conc*dilution_factor]
dat[, my_anticipated_conc_log10 := log10(my_anticipated_conc)]

# Check for any cases where the conc's disagree by more than 0.005 log10-uM
dat[abs(conc_log10 - my_anticipated_conc_log10) >= 0.005, .N, by = .(treatment, sheet_stock_conc, cndx, conc, my_anticipated_conc)][order(treatment, conc)]
# several cases

# Possible reasons for disagreement between conc and my anticipated conc:
# - substance was repeated at a lower conc, so sheet_stock_conc is not the base/max conc in uM
# - conc's were not corrected to sheet_stock_conc at all
# - conc's were "corrected" to the wrong sheet_stock_conc

# Identify substances that were likely tested at a lower starting concentration
dat[, max_conc_by_treatment_culture := max(conc), by = .(treatment, culture)]
dat[max_conc_by_treatment_culture < 0.1*as.numeric(sheet_stock_conc), .N, by = .(treatment, sheet_stock_conc, max_conc_by_treatment_culture)]
#    treatment sheet_stock_conc max_conc_by_treatment_culture    N
# 1:  7126 A12          100.026                      0.100026 1827
# 2:   7126 A4          100.032                      0.300096 1827
# 3:  7126 B11          101.024                      0.101024 1827
# 4:  7126 C11           50.015                      0.050015 1827
# 5:   7126 D4          100.020                      0.100020 1827
# 6:   7126 D5          100.121                      0.100121 1827
# 7:   7126 D7          100.183                      1.000000 1827
# 8:   7126 F1          100.089                      0.100089 1827
# 9:   7126 F8           25.014                      0.025014 1827
# 10:  7126 H10          100.394                      0.100026 1827
# Looks like all of these are 1000X lower than sheet stock conc
# Except for 7126 D7 -> from my notes with Seline, since this one was slighlty less extremely potent, we agreed to retest at with 1uM as new highest conc

# were all of these previously tested at lower conc's?
retested.diff.conc.substances <- dat[, .(length(unique(max_conc_by_treatment_culture))), .(treatment)][V1 > 1, treatment]
dat[wllt == 't', .(length(unique(treatment))), by = .(retested_at_diff_concs = treatment %in% retested.diff.conc.substances,
                                                      max_conc_below_stck = max_conc_by_treatment_culture < 0.1*sheet_stock_conc)]
#    retested_at_diff_concs max_conc_below_stck  V1
# 1:                  FALSE               FALSE 105
# 2:                   TRUE               FALSE   9
# 3:                   TRUE                TRUE   9
# 4:                  FALSE                TRUE   1
# 5:                  FALSE                  NA   2
# Makes sense that the first runs of the 9 retested.diff.conc.substances would be at teh usual conc,
# then the second run woudl be at a diff conc.

# Update the top_conc for chem retested at lower conc
dat[treatment %in% retested.diff.conc.substances & max_conc_by_treatment_culture < 0.1*sheet_stock_conc, .N, by = .(treatment, sheet_stock_conc, max_conc_by_treatment_culture)]
# looks like new top_conc in these cultures is approximately 1/1000 of the sheet_stock_conc -> I'll based my guesses on that, then see how it agrees
# Except for 7126 D7, only decreased by 1/100, which matches my notes
dat[treatment %in% setdiff(retested.diff.conc.substances,'7126 D7') & max_conc_by_treatment_culture < 0.1*sheet_stock_conc, top_conc := sheet_stock_conc/1000]
dat[treatment %in% c('7126 D7') & max_conc_by_treatment_culture < 0.1*sheet_stock_conc, top_conc := sheet_stock_conc/100]

# What's going on where max conc below stck is NA?
dat[wllt == 't' & is.na(sheet_stock_conc), .N, by = .(treatment)]
# treatment    N
# 1: Acetaminophen 3654
# 2:   Bisphenol A 3654
# Confirm that the concentrations don't look like they need to be corrected or standardized across files
dat[wllt == 't' & is.na(sheet_stock_conc), .N, by = .(treatment, cndx, conc)][order(treatment, cndx)]
# hmm.. some inconsistencies in BPA
# What is true? For files that are wrong, what went wrong?
dat[treatment == 'Bisphenol A', .N, by = .(cndx, conc, srcf)][order(cndx)]
# ah, so BPA Was tested in 2 different cultures.
# Looking at the calculations files from groups 19 and 20, looks like a different dilution scheme was used in the different cultures
# Are the conc's at least consistent from within the same culture?
dat[treatment == 'Bisphenol A', .(length(unique(conc))), by = .(cndx, srcf, culture)][V1 > 1]
# empty cool -> I think I can assume that the concentrations are correct!
# For Acetminophen and Bisphenol A

# What's goign on with the 1 substance that was not retested in multiple cultures, but max conc is still below stkc?
# intential or meta data error?
dat[wllt == 't' & !treatment %in% retested.diff.conc.substances & max_conc_by_treatment_culture < 0.1*sheet_stock_conc, .N, by=.(culture, treatment, sheet_stock_conc, cndx, conc, my_anticipated_conc)][order(cndx)]
#     culture treatment sheet_stock_conc cndx        conc my_anticipated_conc   N
# 1: 20210915   7126 A4          100.032    1 0.000300096            0.100032 261
# 2: 20210915   7126 A4          100.032    2 0.001000320            0.333440 261
# 3: 20210915   7126 A4          100.032    3 0.003000960            1.000320 261
# 4: 20210915   7126 A4          100.032    4 0.010003200            3.334400 261
# 5: 20210915   7126 A4          100.032    5 0.030009600           10.003200 261
# 6: 20210915   7126 A4          100.032    6 0.100032000           33.344000 261
# 7: 20210915   7126 A4          100.032    7 0.300096000          100.032000 261
# Ah, I see the note from the lab notebook! A different dilution was used for chemical 4 from G1.
# Specifically:
# "Separate dilution for G1 Chemical 4
# - Dilute 10:1 twice to get 1mm
# - 15uL of 1mm into 35uL of DMSO to get 0.3mm
# - Set 0.3mm as highest dose
# Conc range: 0.3mm - 0.0003mm"
# Will update the top_conc for calculation the of anticipated conc
dat[treatment == '7126 A4' & culture == '20210915', top_conc := (sheet_stock_conc/100)*15/(35+15)] # based on above notes, copied from lab notebook
dat[treatment == '7126 A4', .N, by = .(top_conc, sheet_stock_conc, max_conc_by_treatment_culture)]
#    top_conc sheet_stock_conc max_conc_by_treatment_culture    N
# 1: 0.300096          100.032                      0.300096 1827
# cool!
# Looking at the Calculations file for this substance, dilution scheme is also altered to follow 0.1, 0.3 pattern
dilution.tb.treatmentA4 <- data.table(treatment = '7126 A4', cndx = 7:1)
dilution.tb.treatmentA4[cndx == 7, dilution_cndx_multiplier := 1]
dilution.tb.treatmentA4[cndx == 6, dilution_cndx_multiplier := 15/(15+30)]
dilution.tb.treatmentA4[cndx == 5, dilution_cndx_multiplier := 15/(35+15)]
dilution.tb.treatmentA4[cndx == 4, dilution_cndx_multiplier := 15/(15+30)]
dilution.tb.treatmentA4[cndx == 3, dilution_cndx_multiplier := 15/(35+15)]
dilution.tb.treatmentA4[cndx == 2, dilution_cndx_multiplier := 15/(15+30)]
dilution.tb.treatmentA4[cndx == 1, dilution_cndx_multiplier := 15/(35+15)]
dilution.tb.treatmentA4[, dilution_factor := Reduce(f = `*`, dilution_cndx_multiplier, accumulate = TRUE)]
dat <- merge(dat, dilution.tb.treatmentA4, by = c('treatment','cndx'), all.x = T, suffixes = c('','.add'))
dat[treatment == '7126 A4', dilution_factor := dilution_factor.add]
dat[treatment == '7126 A4', dilution_cndx_multiplier := dilution_cndx_multiplier.add]
dat[, dilution_factor.add := NULL]
dat[, dilution_cndx_multiplier.add := NULL]

# update anticipated conc's, check for remaining differences
dat[, my_anticipated_conc := top_conc*dilution_factor]
dat[, my_anticipated_conc_log10 := log10(my_anticipated_conc)]
dat[abs(conc_log10 - my_anticipated_conc_log10) >= 0.005, .N, by = .(treatment, sheet_stock_conc, cndx, conc, my_anticipated_conc)][order(treatment, conc)]
# empty, sweet!! -> no conc's differ from what I would expect by any meaningful amount

# Since I'm going to give the NTP folks the conc's on a non-log scale, I'm going to make sure that
# the concentrations are consistent when rounded by to 3 sig figs
dat[, conc := signif(conc, 3)]
dat[, my_anticipated_conc := signif(my_anticipated_conc, 3)]
dat[my_anticipated_conc != conc, .N, by = .(culture, treatment, conc, my_anticipated_conc, sheet_stock_conc)]
#     culture treatment  conc my_anticipated_conc sheet_stock_conc   N
# 1: 20220601   7126 D7 3e-03            0.003010          100.183 261
# 2: 20220601   7126 D7 3e-02            0.030100          100.183 261
# 3: 20220601   7126 D7 3e-01            0.301000          100.183 261
# 4: 20220601  7126 H10 3e-04            0.000301          100.394 261
# 5: 20220601  7126 H10 3e-03            0.003010          100.394 261
# 6: 20220601  7126 H10 3e-02            0.030100          100.394 261
# 7126 D7 - this compound was tested at a lower concentration range in 20220601.
# I see in the calculations file (20220601 PFAS+ G3 & DNT Reps 1_ Calculations.xlsx)
# that that stock concentration was not used to adjust the top concentration.
# I will replace with my_anticipated_conc in these cases.
# 7126 H10 - the wrong stock concentration was used to adjust the top concentration
# (see again 20220601 PFAS+ G3 & DNT Reps 1_ Calculations.xlsx)
# I will replace with my_anticipated_conc in these cases.
dat[my_anticipated_conc != conc & treatment %in% c('7126 D7','7126 H10') & culture == '20220601', conc := my_anticipated_conc]
```

## Check concentration units 

```{r}
# **Add units for cyto data
```


```{r}
dat[, .N, by = .(units)]
# any not in uM? If so, convert to uM
# actually, I can include the units column, so I don't have to convert

# What to do where units are NA?
dat[is.na(units), .N, by = .(treatment)]
dat[is.na(units), .N, by = .(endpoint_type)]
# oh right, this is all of the cytotox data!
# can extrapolate based on the MCL's
# then confirm with the sheet stock conc
# First confirm that there is only 1 unique unit per treatment
dat[, length(unique(units[!is.na(units)])), by = .(treatment)][V1 > 1]
# treatment V1
# 1:   9163 A1  2
dat[treatment == '9163 A1', .N, by = .(units, srcf, apid)]
#    units                                                 srcf               apid   N
# 1:  <NA> 20220316_NFA_DNT_NTP 2021_Group 16_Calculations.xlsx 20220316_MW78-7115  14
# 2:  <NA> 20220316_NFA_DNT_NTP 2021_Group 16_Calculations.xlsx 20220316_MW78-7116  14
# 3:  <NA> 20220316_NFA_DNT_NTP 2021_Group 16_Calculations.xlsx 20220316_MW78-7117  14
# 4:    uM                                  DNT_NTP2021_AUC.csv 20220316_MW78-7115  17
# 5:    uM                    DNT_NTP2021_parameters_by_DIV.csv 20220316_MW78-7115  68
# 6: mg/ml                                  DNT_NTP2021_AUC.csv 20220316_MW78-7116 119
# 7: mg/ml                    DNT_NTP2021_parameters_by_DIV.csv 20220316_MW78-7116 476
# 8: mg/ml                                  DNT_NTP2021_AUC.csv 20220316_MW78-7117 119
# 9: mg/ml                    DNT_NTP2021_parameters_by_DIV.csv 20220316_MW78-7117 476
# 10: mg/ml                                  DNT_NTP2021_AUC.csv 20220316_MW78-7115 102
# 11: mg/ml                    DNT_NTP2021_parameters_by_DIV.csv 20220316_MW78-7115 408
# Based on lab notebook, all treatments from Group 16 should be in mg/ml except for 7126 H7
# Makes sense, becaue i believe all treatments from plate 9163 are in mg/ml
# I have no idea why the incorrect unit is appearing for 78-115
# it is correct in the maestro exp log file. Will correct now
dat[treatment == '9163 A1', units := 'mg/ml']
dat[, length(unique(units[!is.na(units)])), by = .(treatment)][V1 > 1]
# empty, cool

# assign units for rows from calculations files
dat[, units := unique(units[!is.na(units)]), by = .(treatment)]

# compare to the sheet stock conc
dat[, .N, by = .(sheet_stock_conc_units, units, wllt)]
#   sheet_stock_conc_units units wllt      N
# 1:                     mM    uM    t 213759
# 2:                   <NA>     %    n  37584
# 3:                   <NA>    uM    t   7308
# 4:                  mg/mL mg/ml    t  36540
dat[is.na(sheet_stock_conc_units), .N, by = .(treatment, sheet_stock_conc_units, units)]
# treatment sheet_stock_conc_units units     N
# 1:          DMSO                   <NA>     % 36018
# 2:   Bisphenol A                   <NA>    uM  3654
# 3:         Water                   <NA>     %  1566
# 4: Acetaminophen                   <NA>    uM  3654
# this is okay. All looks okay!

# Compare with the treatments csv file I made
units.tb <- as.data.table(read.xlsx(file.path(project_name,'treatments_with_units_not_in_mM.xlsx'), sheet = 1))
dat[, .(num_trts = length(unique(treatment))), by = .(units, trt_not_in_mM = treatment %in% units.tb$treatment)]
#    units trt_not_in_mM num_trts
# 1:    uM         FALSE       97
# 2:     %         FALSE        2
# 3: mg/ml          TRUE       20
# cool, lines up!
rm(units.tb)

dat[, .N, by = .(units, from_plate2 = grepl('9163',treatment))]
#    units from_plate2      N
# 1:    uM       FALSE 221067
# 2:     %       FALSE  37584
# 3: mg/ml        TRUE  36540

# note solvents are %
dat[wllt == 'n', .N, by = .(conc, units)]
# conc units     N
# 1:  0.1     % 37584
```



# Finalize well quality

(i.e., add wllq notes by compound cndx and merge with other wllq ntoes to finalize)

```{r}
dat[grepl('LDH',acsn), endpoint_type := 'LDH']
dat[grepl('AB',acsn), endpoint_type := 'CTB'] # this is the abbreviation I'm using in the wllq tables... could change
dat[is.na(endpoint_type), endpoint_type := 'mea']

# Read in and clean wllq table
wllq.tb.by.trt <- as.data.table(read.xlsx(file.path(project_name,'well_quality_notes_per_culture_treatment_cndx.xlsx'), sheet = 1))
setnames(wllq.tb.by.trt, old = 'source', new = 'source_wllq_notes_by_trt')
setnames(wllq.tb.by.trt, old = 'wllq', new = 'wllq_by_trt')
setnames(wllq.tb.by.trt, old = 'wllq_notes', new = 'wllq_notes_by_trt')

# Expand the sections where cndx == 'all'
cndx_list <- unique(dat$cndx)
add.tb <- rbindlist(lapply(cndx_list,
                           function(cndxi) cbind(wllq.tb.by.trt[cndx %in% c('all') | is.na(cndx), .SD, .SDcols = setdiff(names(wllq.tb.by.trt),'cndx')],
                                                 'cndx' = cndxi)))
wllq.tb.by.trt <- wllq.tb.by.trt[!(cndx %in% 'all' | is.na(cndx))]
wllq.tb.by.trt <- rbind(wllq.tb.by.trt, add.tb)

# split by MEA, CTB, LDH, etc
affected_endpoints_list <- unique(unlist(stri_split(wllq.tb.by.trt$affected_endpoints, regex = '[,; ]')))
wllq.tb.by.trt <- rbindlist(lapply(affected_endpoints_list,
                                   function(endpoint_typei) cbind(wllq.tb.by.trt[grepl(endpoint_typei,affected_endpoints),
                                                                                 .SD, .SDcols = setdiff(names(wllq.tb.by.trt),'affected_endpoints')],
                                                                  'endpoint_type' = endpoint_typei)))

# Make sure there is just 1 row per well
check.ids <- wllq.tb.by.trt[, .N, by = .(culture_date, treatment, cndx, endpoint_type)][N > 1, .(culture_date, treatment, cndx, endpoint_type)]
setkey(wllq.tb.by.trt, culture_date, treatment, cndx, endpoint_type)
wllq.tb.by.trt[.(check.ids)] # collapse these notes
unique(wllq.tb.by.trt$wllq_by_trt)
wllq.tb.by.trt$wllq_by_trt <- factor(wllq.tb.by.trt$wllq_by_trt, levels = c('0','evaluate','1'), ordered = T)
wllq.tb.by.trt.condensed <- wllq.tb.by.trt[, .(wllq_by_trt = min(wllq_by_trt),
                                               wllq_notes_by_trt = paste0(sort(unique(wllq_notes_by_trt )),collapse = ", "),
                                               source_wllq_notes_by_trt = paste0(sort(unique(source_wllq_notes_by_trt)),collapse = ", ")),
                                           by = c(setdiff(names(wllq.tb.by.trt), c('wllq_by_trt','wllq_notes_by_trt','source_wllq_notes_by_trt')))]
check.ids <- wllq.tb.by.trt.condensed[, .N, by = .(culture_date, treatment, cndx, endpoint_type)][N > 1, .(culture_date, treatment, cndx, endpoint_type)]
setkey(wllq.tb.by.trt.condensed, culture_date, treatment, cndx, endpoint_type)
wllq.tb.by.trt.condensed[.(check.ids)]
# empty, cool

# Merge in!
dat[, in_dat := 1]
intersect(names(dat), names(wllq.tb.by.trt.condensed))
dat[, culture_date := as.numeric(sub('_.*','',apid))]
wllq.tb.by.trt.condensed[, cndx := as.numeric(cndx)]
dat <- merge(dat, wllq.tb.by.trt.condensed, by = c('culture_date','treatment','cndx','endpoint_type'), all = T)

# Check for rows in wllq.tb.by.trt that did not match a row in dat
dat[is.na(in_dat)]
# empty, cool

# Confirm groups align
dat[, group_by_calc_file := unique(stri_extract(srcf[grepl('Calculations',srcf)], regex = 'Group[ _]*[0-9]*')), by = .(apid)]
dat[!is.na(group), .N, by = .(group, group_by_calc_file)][order(group)]
# just added as an extra confirmation that I entered the data correctly in well quality notes table

# merge wllq notes
unique(dat$wllq_by_well)
dat$wllq_by_well <- factor(dat$wllq_by_well, levels =  c('0','evaluate','1'), ordered = T)
dat[, wllq_merged := pmin(wllq_by_well, wllq_by_trt, na.rm = T)]
dat[, wllq_notes_merged := paste(wllq_notes_by_well, wllq_notes_by_trt, sep = "; ")]
dat[, .N, by = .(wllq_by_well, wllq_by_trt, wllq_merged)]
# wllq_by_well wllq_by_trt wllq_merged      N
# 1:            1        <NA>           1 231676
# 2:            1    evaluate    evaluate  13831
# 3:            1           1           1  27658
# 4:            0        <NA>           0  18623
# 5:            0    evaluate           0   1568
# 6:            0           1           0      8
# 7:            1           0           0   1827
# looks good

View(dat[, .N, by = .(wllq_notes_merged, wllq_merged)][order(wllq_merged)])
# looks like all wllq==0 instances are due to substance that was noisy and repeated
# or some wllq issue
```

# Confirm the solvent

# Check for NA rvals

# FINAL DATA CHECKS 

See Kelly's not to pass back to lab technicians - what would be good for them to see? graphs? # of chem? values? the csv?

Maybe a reminder of how it's normalized :)

Include check for expected number of replicates (with wllq == 1) (Check for expected number of technical replicates (sometimes helpful for identifying typo-s, e.g. if a chemical was not supposed to be repeated or appears in multiple rows of a plate));
determine which repeats to keep

```{r}
# this section is to confirm that the data has been processed correctly
source(file.path(scripts.dir, 'dataset_checks.R'), echo = FALSE)

# run this fun... or outdated?

# Define putative final wllq and wllq_notes
dat[, wllq := wllq_merged]
dat[, wllq_notes := wllq_notes_merged]
dataset_checks(dat)

# Check for the expected number of technical replicates
dat[wllt == 't', .(length(unique(paste0(apid,rowi,coli)))), by = .(DNTP_blind_code, conc)][V1 != 3]
# several cases..
# do you except these cases to have more than or less than 3 replicates?
# Were some samples repeated, and only certain repeats meant to be included?
# Most cases that were meant to be repeated should have been repeated due to noisy should have wllq 0 for previous run
dat[wllt == 't' & wllq == '1', .(length(unique(paste0(apid,rowi,coli)))), by = .(DNTP_blind_code, conc, rescreened_lower_conc = treatment %in% retested.diff.conc.substances)][V1 != 3]
#             spid      conc rescreened_lower_conc V1
# 1:   Bisphenol A  0.030000                 FALSE  6
# 2:   Bisphenol A  0.300000                 FALSE  6
# 3:   Bisphenol A  3.000000                 FALSE  6
# 4:   Bisphenol A 30.000000                 FALSE  6
# 5:      7126 C11  0.050015                  TRUE  6
# 6:       7126 D4  0.100020                  TRUE  6
# 7:       7126 D5  0.100121                  TRUE  6
# 8:       7126 F1  0.100089                  TRUE  6
# 9:       7126 F8  0.025014                  TRUE  6
# 10: Acetaminophen  0.030000                 FALSE  6
# 11: Acetaminophen  0.100000                 FALSE  6
# 12: Acetaminophen  0.300000                 FALSE  6
# 13: Acetaminophen  1.000000                 FALSE  6
# 14: Acetaminophen  3.000000                 FALSE  6
# 15: Acetaminophen 10.000000                 FALSE  6
# 16: Acetaminophen 30.000000                 FALSE  6
# cool, all assay controls or chemicals that were supposed to be repeated

if(save_notes_graphs) {
  sink() # close the txt log file
  graphics.off() # clear the plot history
}
```

# Additional checks and wllq adjustments 
```{r}
# Any other plots or things to check?

# Why are some apid appearing to have no treatments in the data set checks graphs?
library(ggplot2)

dat[, plot_apid := sub("_","\n",apid)]
ggplot(dat[grepl('firing_rate_mean_DIV12',acsn)], aes(x = plot_apid, y = rval))+
  geom_jitter(aes(color = as.factor(wllt), pch = wllt), height = 0, width = 0.15)+
  scale_shape_manual(values = c('t' = 1,
                                'n' = 19))+
  theme(axis.text.x = element_text(angle = 90, vjust = 0.5))
# yep, this looks okay


## Confirm intended repeats performed --------------------------------------

dat[, repeated_samples := as.numeric(length(unique(culture_date))>1), by = .(treatment, DNTP_blind_code)]

repeats.tb <- as.data.table(read.xlsx('DNT_NTP2021/check_for_chem_to_rescreen/DNT_NTP2021_MEA_NFA_rescreen_recommendations_2022-05-26.xlsx', sheet = 'tcplfit2 summary'))
repeats.tb[, .N, by = .(rescreen)]
# rescreen  N
# 1:        1 20
# 2:        0 95
# 3: optional  2
setnames(repeats.tb, old = 'spid', new = 'treatment')

# Merge
setdiff(repeats.tb$treatment, dat$treatment) # "Acetamenophin"
repeats.tb[treatment == "Acetamenophin", treatment := "Acetaminophen"]
dat <- merge(dat, repeats.tb[, .(treatment, rescreen, rescreen_note)], by = 'treatment', all.x = 'T')
dat[, .(num_treatments = length(unique(treatment))), by = .(rescreen, repeated_samples)]
#    rescreen repeated_samples num_treatments
# 1:        0                0             91
# 2:        1                1             20
# 3:        0                1              4
# 4: optional                0              2
# 5:     <NA>                1              2

# first 2 rows are in agreement

# 4 samples were repeated that I had not suggested to repeat
dat[rescreen == 0 & repeated_samples == 1, .N, by = .(treatment)]
# treatment     N
# 1:       7126 A3  3654
# 2: Acetaminophen  3654
# 3:   Bisphenol A  3654
# 4:          DMSO 36018
# assay controls make sense
# but what about the top one/
dat[treatment == '7126 A3', .N, by = .(culture, wllq, wllq_notes)]
#     culture     wllq                                                             wllq_notes  source_wllq_notes_by_trt    N
# 1: 20210915 evaluate ; dropped out of solution, precipitates in media (need to be repeated) lab notebook, readme note 1827
# 2: 20220330        1                                                                   ; NA                      <NA> 1827
# ah, okay, makes sense!!

# Looks like the 2 optional-to-repeat samples were not repeated

# The cases for which teh treatments were not in rescreen.tb
dat[is.na(rescreen), .N, by = .(treatment)]
#        treatment    N
# 1:       7126 H7 3654
# 2:         Water 1566
# water makes sense... but what's going on with the other one?
dat[treatment == '7126 H7', .N, by = .(culture_date, wllq, wllq_notes)]
# culture_date wllq                                      wllq_notes    N
# 1:     20220316    0 ; Need to repeat. Got wrong chemical on 3/21/22 1827
# 2:     20220615    1                                            ; NA 1827
# oh.... got it.


# Conclusions;
# all of the samples that I suggested that we repeat in DNT_NTP2021_MEA_NFA_rescreen_recommendations_2022-05-26.xlsx
# were rescreened.
# The 2 smaples that I said were "optional" to repeat were not repeated.
# The 2 assay controls (BPA and Acetaminophen) were repeated.
# 1 sample was repeated because precipitate was observed in the first culture.
# another sample was repeated because the wrong substance was used in the first culture.


```
## Clean wllq notes 
```{r}
# After discussion with Tim 7/29/2022, confirmed that where the wllq note indicates that "Precipitates in dosing solution but soluble in 37C incubator", no wllq note is need
# and wllq can be 1
dat[grepl('precipitates in media, but not when in 37 C incubator', wllq_notes), .N, by = .(wllq, wllq_notes)]
# where wllq is currently 0 -> there are other reasons for the wllq to be 0
# where wllq is "evaluate", we have determined that this note regarding precipitate when not in incubator is irrelevant (and the hot water shut off in building had no clear effects)
dat[grepl('precipitates in media, but not when in 37 C incubator', wllq_notes) & wllq == 'evaluate', wllq := '1']
dat[, wllq_notes := sub('precipitates in media, but not when in 37 C incubator[ ,]*','',wllq_notes)] # remove this wllq_note

# Remove notes of "different dilution approach used" -> this doesn't really provide any substance information
# Will have to refere to lab notebooks if want to know diluiton approach for each treatment and culture
dat[grepl('Different dilution approached used',wllq_notes), .N, by = .(wllq_notes)]
dat[, wllq_notes := sub('[ ]*Different dilution approached used[ ]*','',wllq_notes)]

# Remove notes suggesting to repeat compound at a lower concentration
# (these were initial suggestions for some compounds before we discussed and decided which treatments to repeat)
dat[grepl('lower conc',wllq_notes), .N, by = .(wllq_notes)]
# wllq_notes    N
# 1:                                                               dropped out of solution, precipitates in media, need to be repeated on lower concentration 1827
# 2:                                                                                Hot water shut off in building; will be repeated on a lower concentration 7308
# 3:                                 CTB incubation time is less than one hour; Hot water shut off in building; needs to be repeated on a lower concentration    7
# 4:                                                                            Hot water shut off in building; needs to be repeated on a lower concentration 1820
# 5:                                                                         Hot water shut off in building; may need to be repeated on a lower concentration 1305
# 6: Hot water shut off in building; may need to be repeated on a lower concentration, precipitates in dosing plate but dissolved in well (10 in 490uL media)  522
# 7:                                                                                                         may need to be repeated on a lower concentration 9135
dat[, wllq_notes := sub('[^,;]*repeated on (a )*lower concentration[,]*','',wllq_notes)]

# Where treatment is noted to be a different color (i.e., the chemical itself, not when mixed with media), remove note
dat[grepl('(yellow)|(brown)|(amber)|(color)',wllq_notes), .N, by = .(treatment, wllq, wllq_notes)]
# treatment wllq                                                                                                                                                               wllq_notes    N
# 1:   7126 A9    1                                                                                         ; Compound may have altered pH (when mixed with media, change into yellow color) 1827
# 2:  7126 B12    1                                                                                                                          Hot water shut off in building; yellow in color   42
# 3:  7126 B12    1                                                                                                                        Hot water shut off in building; ; yellow in color 1785
# 4:   9163 B6    1              Coded Plate Map stock conc <= 10. Exact concentration could not be determined.; (Chemical 1) Noted to be brown in color in dilution plate preparation sheet 1826
# 5:   9163 B6    0 cell debris; Coded Plate Map stock conc <= 10. Exact concentration could not be determined.; (Chemical 1) Noted to be brown in color in dilution plate preparation sheet    1
# 6:   9163 B7    1                                                                                            ; (Chemical 2) Noted to be amber in color in dilution plate preparation sheet 1827
# 7:   9163 B8    1           Coded Plate Map stock conc <= 10. Exact concentration could not be determined.; (Chemical 3) Noted to be lt amber in color in dilution plate preparation sheet 1827
dat[!grepl('pH',wllq_notes), wllq_notes := sub('[; ]*[^;]*color[^;]*','',wllq_notes)] # remov eteh note, unless it pertains to the pH
dat[grepl('(yellow)|(brown)|(amber)|(color)',wllq_notes), .N, by = .(treatment, wllq, wllq_notes, wllq_notes)]
# treatment wllq                                                                     wllq_notes                                                                   wllq_notes.1    N
# 1:   7126 A9    1 Compound may have altered pH (when mixed with media, change into yellow color) Compound may have altered pH (when mixed with media, change into yellow color) 1827

# Clean wllq_notes
dat[, wllq_notes := sub('; ;',';',wllq_notes)]
dat[, wllq_notes := sub('^;[ ]*','',wllq_notes)]
dat[, wllq_notes := sub(';[ ]*$','',wllq_notes)]
dat[, wllq_notes := sub('; NA','',wllq_notes)]
dat[, wllq_notes := sub('^NA$','',wllq_notes)]
dat[, wllq_notes := sub(',[ ]*$','',wllq_notes)]
```

## Review substances with precipitate, determine which repeat to keep 
```{r}
# Note that for 20220330_NFA_DNT 2021_Group 19: In lab notebook, was noted that no precipitate was observed
# Just confirmed that all observations off precipitate noted in lab notebook or README notes have been entered in the well_quality_nots_per_culture_treatment_cndx.xlsx

# Let's just do this case by case
dat[, precipitate_observed := as.numeric(grepl('precipitate',tolower(wllq_notes)) | grepl('drop',tolower(wllq_notes)))]
dat[, precipitate_note := stri_extract(tolower(wllq_notes), regex = '[;]?[^;]*((precipitate)|(drop))+[^;]*[;]?')]
dat[, .N, by = .(precipitate_note)]
dat[grepl('precipitate',tolower(wllq_notes)) | grepl('drop',tolower(wllq_notes)), .N, by = .(precipitate_note)]
# cool,I didin't miss anything
treatments.sometimes.precipitate <- sort(dat[precipitate_observed == 1, unique(treatment)])
# cat omething to initialize text for review
cat(paste0('# ',treatments.sometimes.precipitate,'\ndat[treatment == "',treatments.sometimes.precipitate,'", .N, by = .(DNTP_blind_code, treatment, culture, wllq, wllq_notes)]'), sep = '\n\n')


# 7126 A11
dat[treatment == "7126 A11", .(cndxs_affected = paste0(sort(unique(cndx)),collapse=",")), by = .(DNTP_blind_code, treatment, culture, wllq, wllq_notes)]
#    DNTP_blind_code treatment  culture        wllq              wllq_notes cndxs_affected
# 1:            2223  7126 A11 20210915    evaluate dropped out of solution  1,2,3,4,5,6,7
# This treatment dropped out of solution, but was not repeated
# See email conversation with Tim 7/29/22 - can keep this data, but add a clarifying note
dat[treatment == "7126 A11" & wllq == 'evaluate', `:=`(wllq = '1',
                                                       wllq_notes = 'Precipitate observed at some concentrations, actual concentrations are dubious')]

# 7126 A12
dat[treatment == "7126 A12", .(max_conc = max(conc), .N), by = .(DNTP_blind_code, treatment, culture, wllq, wllq_notes)]
#   DNTP_blind_code treatment  culture     wllq                                     wllq_notes max_conc    N
# 1:            1852  7126 A12 20210915 evaluate dropped out of solution, precipitates in media    100.0 1827
# 2:            1852  7126 A12 20220601        1                                             NA      0.1 1827
# This sample was repeated, presumably with a different dosing scheme. Will only keep repeats
dat[treatment == "7126 A12" & culture == '20210915', `:=`(wllq = '0',
                                                          wllq_notes = 'Precipitate observed at some concentrations, actual concentrations are dubious. Compound was retested.')]

# 7126 A3
dat[treatment == "7126 A3", .(max_conc = max(conc), .N), by = .(DNTP_blind_code, treatment, culture, wllq, wllq_notes)]
#   DNTP_blind_code treatment  culture        wllq                                                           wllq_notes max_conc    N
# 1:            4285   7126 A3 20210915    evaluate dropped out of solution, precipitates in media (need to be repeated)       50 1827
# 2:            4285   7126 A3 20220330           1                                                                   NA       50 1827
# same as above
dat[treatment == "7126 A3" & culture == '20210915', `:=`(wllq = '0',
                                                         wllq_notes = 'Precipitate observed at some concentrations, actual concentrations are dubious. Compound was retested.')]

# 7126 B11
dat[treatment == "7126 B11", .(max_conc = max(conc), .N), by = .(DNTP_blind_code, treatment, culture, wllq, wllq_notes)]
#    DNTP_blind_code treatment  culture     wllq                                             wllq_notes max_conc    N
# 1:            3107  7126 B11 20210929 evaluate Hot water shut off in building; precipitates in media.  101.000 1827
# 2:            3107  7126 B11 20220601        1                                                     NA    0.101 1820
# 3:            3107  7126 B11 20220601        0                  LDH data not collected for this plate    0.101    7
# same as above
dat[treatment == "7126 B11" & culture == '20210929', `:=`(wllq = '0',
                                                          wllq_notes = 'Precipitate observed at some concentrations, actual concentrations are dubious. Compound was retested.')]

# 7126 B2
dat[treatment == "7126 B2", .(cndxs_affected = paste0(sort(unique(cndx)),collapse=",")), by = .(DNTP_blind_code, treatment, culture, wllq, wllq_notes)]
#   DNTP_blind_code treatment  culture     wllq                                             wllq_notes cndxs_affected
# 1:            4446   7126 B2 20210929 evaluate Hot water shut off in building; precipitates in media.  1,2,3,4,5,6,7
# only 1 culture tested, so we have to use this data
# See email conversation with Tim 7/29/22 - can keep this data, but add a clarifying note
dat[treatment == "7126 B2" & wllq == 'evaluate', `:=`(wllq = '1',
                                                      wllq_notes = 'Hot water shut off in building; precipitate observed at some concentrations, actual concentrations are dubious')]

# 7126 E1
dat[treatment == "7126 E1", .(cndxs_affected = paste0(sort(unique(cndx)),collapse=",")), by = .(DNTP_blind_code, treatment, culture, wllq, wllq_notes)]
# DNTP_blind_code treatment  culture     wllq                                                                                             wllq_notes cndxs_affected
# 1:            4863   7126 E1 20211208        1                                                                         Hot water shut off in building      1,2,3,4,5
# 2:            4863   7126 E1 20211208 evaluate Hot water shut off in building; precipitates in dosing plate but dissolved in well (10 in 490uL media)            6,7
# From conversation with Tim 7/29/22 - wllq == 1, but keep wllq note
dat[treatment == "7126 E1" & wllq == 'evaluate', wllq := '1']

# 7126 E2
dat[treatment == "7126 E2", .(cndxs_affected = paste0(sort(unique(cndx)),collapse=",")), by = .(DNTP_blind_code, treatment, culture, wllq, wllq_notes)]
#    DNTP_blind_code treatment  culture     wllq                                                                                             wllq_notes cndxs_affected
# 1:            4825   7126 E2 20211208        1                                                                     Hot water shut off in building; NA      1,2,3,4,5
# 2:            4825   7126 E2 20211208 evaluate Hot water shut off in building; precipitates in dosing plate but dissolved in well (10 in 490uL media)            6,7
# From conversation with Tim 7/29/22 - wlq == 1, but keep wllq note
dat[treatment == "7126 E2" & wllq == 'evaluate', wllq := '1']

# 7126 E3
dat[treatment == "7126 E3", .(cndxs_affected = paste0(sort(unique(cndx)),collapse=",")), by = .(DNTP_blind_code, treatment, culture, wllq, wllq_notes)]
# DNTP_blind_code treatment  culture     wllq                                                                                             wllq_notes cndxs_affected
# 1:            4894   7126 E3 20211208        1                                                                         Hot water shut off in building      1,2,3,4,5
# 2:            4894   7126 E3 20211208 evaluate Hot water shut off in building, precipitates in dosing plate but dissolved in well (10 in 490uL media)            6,7
# From conversation with Tim 7/29/22 - wlq == 1, but keep wllq note
dat[treatment == "7126 E3" & wllq == 'evaluate', wllq := '1']

# 7126 E7
dat[treatment == "7126 E7", .(cndxs_affected = paste0(sort(unique(cndx)),collapse=",")), by = .(DNTP_blind_code, treatment, culture, wllq, wllq_notes)]
# DNTP_blind_code treatment  culture     wllq                                                                                             wllq_notes cndxs_affected
# 1:            4269   7126 E7 20211208        1                                                                     Hot water shut off in building; NA    1,2,3,4,5,6
# 2:            4269   7126 E7 20211208 evaluate Hot water shut off in building; precipitates in dosing plate but dissolved in well (10 in 490uL media)              7
# From conversation with Tim 7/29/22 - wlq == 1, but keep wllq note
dat[treatment == "7126 E7" & wllq == 'evaluate', wllq := '1']

# 7126 E8
dat[treatment == "7126 E8", .(cndxs_affected = paste0(sort(unique(cndx)),collapse=",")), by = .(DNTP_blind_code, treatment, culture, wllq, wllq_notes)]
# DNTP_blind_code treatment  culture     wllq                                                                                             wllq_notes cndxs_affected
# 1:            4105   7126 E8 20211208        1                                                                     Hot water shut off in building; NA    1,2,3,4,5,6
# 2:            4105   7126 E8 20211208 evaluate Hot water shut off in building; precipitates in dosing plate but dissolved in well (10 in 490uL media)              7
# From conversation with Tim 7/29/22 - wlq == 1, but keep wllq note
dat[treatment == "7126 E8" & wllq == 'evaluate', wllq := '1']

# Confirm every chemical has a usable sample
all.treatments <- dat[wllt == 't', unique(treatment)]
dat[wllq == '1', setdiff(all.treatments, treatment)]
# empty, cool

```

## Other wllq issues 
```{r}

### Confirm well with cell debris -------------------------------------------

# Background:
# Lab notebook indicates "Plate 1 78-7220 LDH A1, B2, D4 cell debris"
# While README note indicated that following wells shoudl be discarded: ""78-7220 A1, 78-7220 B1, 78-7220 D4"
# I defaulted set wllq to 0 for well B2 instead of B1
# confirming that looks correct

plot.culture <- dat[grepl('MW78-7220',apid), unique(culture_date)]
plotdat <- dat[culture_date %in% plot.culture & grepl("LDH",acsn)]
plotdat$wllq <- as.character(plotdat$wllq)
plotdat[grepl('MW78-7220',apid) & rowi == 2 & coli == 1, wllq := '78-7220 B1']
ggplot(plotdat, aes(x = rval, y = treatment)) +
  geom_jitter(aes(color = cndx, size = wllq), pch = 1, height = 0.15, width = 0)+
  scale_size_manual(values= c('1' = 2,
                              '0' = 4,
                              '78-7220 B1' = 6))+
  ggtitle(paste0('LDH rvals for culture ',plot.culture))

# Well 78-7220 B1 looks completely normal compared to both the other replicates for
# I'm don't think I need to change teh wllq for that well.


### Note regarding temporary misdose of Bisphenal A in 75-9317 --------------

# From the lab notebook: "Plate 75-9317, DIV5 Dosed 7126 H11 into row E [meant to be Bisphenol A], aspirated and add fresh media, dosed with Bisphenol A."
# When a momentary misdose has happened previously for other project, it did not noticably affect the results.
# I am double checking now.
plot.culture <- dat[grepl('75\\-9317',apid), unique(culture_date)]
plotdat <- dat[culture_date %in% plot.culture & grepl("LDH",acsn)]
plotdat$wllq <- as.character(plotdat$wllq)
plotdat[, .N, by = .(wllq)]
# all 1
ggplot(plotdat, aes(x = rval, y = treatment)) +
  geom_jitter(aes(color = cndx, pch = apid), width = 0, height = 0.15)+
  scale_shape_manual(values = c("20211027_MW75-9315" =  1, # circle
                                "20211027_MW75-9316" =8, # asterisk
                                "20211027_MW75-9317" = 6 # upside down triangle
  ))
# Points from 20211027_MW75-9317 don't appear at all atypical compared to points from other plates for Bisphenol A
# no changes to wllq are warranted.


### Any other cases to evaluate? --------------------------------------------

dat[wllq == 'evaluate', .N]
# empty, cool!


## Set wllq==0 for controls on plates where all treatments were repeated ----

# inspired by investigations/assess_impact_of_hot_water_shutoff_in_building_DNT_NTP2021-2022-07-27.R,
# I realized that there are certain plates for which all treatments were determined to be very noisy and had to be repeated
# or were very potent (and so any potential noise was likely masked by the cytotoxicity).
# Since all of these 'noisy' treatments replicates come from 1 culture date, and wllq == 0 for these treatments already,
# I think we can conclude that this culture was off, and so we don't want to include the control wells from this culture
# in the calculation of dataset-wide values such as the bmad

# Confirm that all treatments determined to be "noisy" are coming from the same culture
dat[grepl('noisy',tolower(wllq_notes)), .(num_trts = length(unique(treatment))), by = .(apid, wllq)]
#                   apid wllq num_trts
# 1: 20211110_MW78-6208    0        6
# 2: 20211110_MW78-6209    0        6
# 3: 20211110_MW78-6210    0        6
# 4: 20211110_MW78-6211    0        5
# 5: 20211110_MW78-6212    0        5
# 6: 20211110_MW78-6213    0        5

# Confirmation of what's going on with the 6th treatment from the second set of plates
# for which there is no note of noise in the wllq_notes
dat[apid %in% c('20211110_MW78-6211','20211110_MW78-6212','20211110_MW78-6213') & wllq == '1', .N, by = .(treatment, wllt, wllq_notes)]
#    treatment wllt                                                                wllq_notes    N
# 1:  7126 C11    t Hot water shut off in building; will be repeated on a lower concentration 1827
# 2:      DMSO    n                                        Hot water shut off in building; NA 1566
# 7126 C11 was very potent, and so was repeated at a lower concentration
# I believe that this substance was so potent that any potential noise was likely masked by the cytotoxicity.
# Given that all 5 other treatments on these plates were foudn to be noisy,
# and all 6 other treatments in this culture from the other set of plates,
# I don't think any of the data from 20211110 should be kept

dat[culture_date == '20211110', .N, by = .(apid)]
# apid    N
# 1: 20211110_MW78-6208 4176
# 2: 20211110_MW78-6209 4176
# 3: 20211110_MW78-6210 4176
# 4: 20211110_MW78-6211 4176
# 5: 20211110_MW78-6212 4176
# 6: 20211110_MW78-6213 4176

# Update wllq
dat$wllq <- as.numeric(as.character(dat$wllq)) # make wllq no longer a factor
dat[culture_date == '20211110', `:=`(wllq = 0,
                                     wllq_notes = paste0(ifelse(is.na(wllq_notes), '', paste0(wllq_notes, '; ')),
                                                         '20211110 culture produced noisy results, setting wllq to 0 for all points'))]
```

# Save results 
```{r}
# any superfluous columns to remove?
names(dat)
dat[, c('culture','conc_calc_file','conc_calc_file_log10','dilution_cndx_multiplier','in_dat','group','plot_apid') := NULL]

# save dat and graphs
setkey(dat, NULL)
description <- paste0('DNTP MEA NFA prepared data
Date Ran: ',as.character.Date(Sys.Date()))
save(dat, description, file = file.path(root.output.dir, project_name, "output", paste0(project_name,"_longfile.RData")))
rm(dat)

cat("\nDone!\n")
```

